from unittest.mock import patch

from src.interface.adapters import adapt_langgraph_event


@patch("src.interface.adapters.get_agent_id_from_node")
def test_on_chain_end_status_behavior(mock_get_agent_id):
    """
    Test that adapt_langgraph_event does NOT automatically emit agent.status='done'
    just because a node finished (on_chain_end).
    """
    # Setup
    thread_id = "test_thread"
    seq_id = 1
    run_id = "test_run"

    # 1. Simulate a node that maps to an agent (e.g. debate_aggregator -> debate)
    mock_get_agent_id.return_value = "debate"
    node_name = "debate_aggregator"

    event = {
        "event": "on_chain_end",
        "metadata": {"langgraph_node": node_name},
        "data": {"output": {"some": "data"}},
    }

    # Execute
    # We patch NodeOutputMapper to return a dummy payload so we get a state.update event
    with patch("src.interface.mappers.NodeOutputMapper.transform") as mock_transform:
        mock_transform.return_value = {"updated": "data"}

        events = adapt_langgraph_event(event, thread_id, seq_id, run_id)

    # Assert
    # We expect:
    # 1. state.update event (from NodeOutputMapper)
    # 2. NO agent.status='done' event (This is what we are fixing)

    state_updates = [e for e in events if e.type == "state.update"]
    status_updates = [e for e in events if e.type == "agent.status"]

    assert len(state_updates) == 1
    assert state_updates[0].source == "debate"

    # BEFORE FIX: This assertion would fail (we'd see 1 status update)
    # AFTER FIX: This assertion should pass (we expect 0 auto-generated status updates)
    assert (
        len(status_updates) == 0
    ), f"Expected 0 status updates, found: {[e.data for e in status_updates]}"


@patch("src.interface.adapters.get_agent_id_from_node")
def test_explicit_status_update_via_state(mock_get_agent_id):
    """
    Test that if the state update ITSELF contains node_statuses, it is propagated
    via state.update (which the frontend reducer handles), not as a separate agent.status event
    generated by the adapter logic.
    """
    # Setup
    # This reflects how manual status updates work (e.g. executor returning node_statuses={"executor": "done"})
    mock_get_agent_id.return_value = "executor"

    event = {
        "event": "on_chain_end",
        "metadata": {"langgraph_node": "executor"},
        "data": {
            "output": {"update": {"node_statuses": {"executor": "done"}}, "goto": "END"}
        },
    }

    # Execute
    with patch("src.interface.mappers.NodeOutputMapper.transform") as mock_transform:
        # The mapper passes through the dict
        mock_transform.return_value = {"node_statuses": {"executor": "done"}}

        events = adapt_langgraph_event(event, "t1", 1, "r1")

    # Assert
    # We expect a state.update containing the node_statuses
    # We do NOT expect an auto-generated agent.status event on top of that

    state_update = next((e for e in events if e.type == "state.update"), None)
    assert state_update is not None
    assert state_update.data["node_statuses"] == {"executor": "done"}

    # Verify we DO get an agent.status event because it was explicit in the output
    status_events = [e for e in events if e.type == "agent.status"]
    assert len(status_events) == 1
    assert status_events[0].data["status"] == "done"
    assert status_events[0].source == "executor"
