from typing import cast

from pydantic import BaseModel, Field, ValidationError, field_validator

from src.common.contracts import AGENT_OUTPUT_VERSION
from src.common.types import (
    AgentOutputArtifactPayload,
    AgentOutputKind,
    ArtifactReferencePayload,
    JSONObject,
)


class ArtifactReference(BaseModel):
    """
    L3 冷數據指針 (Cold Data Pointer)

    Points to large artifacts stored in the Artifact Store.
    Frontend can fetch these asynchronously via the download_url.
    """

    artifact_id: str = Field(..., description="UUID of the artifact in the store")
    download_url: str = Field(
        ...,
        description="API endpoint to fetch the artifact (e.g., /api/artifacts/{id})",
    )
    type: str = Field(
        ...,
        description="Artifact type identifier (e.g., 'financial_report', 'news_analysis')",
    )


class AgentOutputArtifact(BaseModel):
    """
    Standard container for all Sub-Agent outputs.

    This structure implements a three-tier data architecture:
    - L1 (summary): Message bubble text (<500 chars) - Always present
    - L2 (preview): Hot data for immediate UI rendering (<1KB) - Optional
    - L3 (reference): Cold data pointer for async loading - Optional

    This ensures efficient state management by avoiding large data duplication
    in LangGraph checkpoints.
    """

    kind: AgentOutputKind = Field(
        ...,
        description=(
            "Output contract kind discriminator "
            "(e.g. 'fundamental_analysis.output')."
        ),
    )
    version: str = Field(
        default=AGENT_OUTPUT_VERSION,
        description="Output contract version. Must be 'v1'.",
    )

    # L1: Message bubble text
    summary: str = Field(
        ..., description="L1: Short summary for message bubble (<500 chars)"
    )

    # L2: Preview (熱數據) - UI 立即渲染用
    preview: dict[str, object] | None = Field(
        default=None,
        description="L2: Hot data for immediate UI rendering (<1KB). Generated by Mapper from State.",
    )

    # L3: Reference (冷數據) - UI 異步加載用
    reference: ArtifactReference | None = Field(
        default=None,
        description="L3: Cold data pointer for async loading. Points to Artifact Store.",
    )

    @field_validator("version", mode="before")
    @classmethod
    def _version(cls, value: object) -> str:
        if value != AGENT_OUTPUT_VERSION:
            raise TypeError(f"Agent output version must be {AGENT_OUTPUT_VERSION!r}")
        return AGENT_OUTPUT_VERSION


def to_artifact_reference_payload(
    reference: ArtifactReference,
) -> ArtifactReferencePayload:
    return cast(ArtifactReferencePayload, reference.model_dump(mode="json"))


def to_artifact_payload(artifact: AgentOutputArtifact) -> AgentOutputArtifactPayload:
    return cast(AgentOutputArtifactPayload, artifact.model_dump(mode="json"))


def parse_agent_output_artifact_payload(
    value: object, context: str = "agent output artifact"
) -> AgentOutputArtifactPayload:
    try:
        model = AgentOutputArtifact.model_validate(value)
    except ValidationError as exc:
        raise TypeError(f"{context} validation failed: {exc}") from exc
    payload = model.model_dump(mode="json")
    return cast(AgentOutputArtifactPayload, payload)


def build_artifact_payload(
    kind: AgentOutputKind,
    summary: str,
    preview: JSONObject | None,
    reference: ArtifactReference | None,
    version: str = AGENT_OUTPUT_VERSION,
) -> AgentOutputArtifactPayload:
    artifact = AgentOutputArtifact(
        kind=kind,
        version=version,
        summary=summary,
        preview=preview,
        reference=reference,
    )
    return to_artifact_payload(artifact)
